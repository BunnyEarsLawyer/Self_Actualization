Vocab ch1
- expression = smallest unit of computation. 1 or more operand
- clog = ostream object tied to the standard error
- buffer 

Vocab

- auto = deduces the type of a variable from its initializer

- constexpr

- nullptr  

- alias declaration
- base type
- bind
- compound type
- const reference = colloquial sysnonym for reference to const
- constant expression
- default initialization
  - Objects of built-in type are init to 0
  - local scope are uninitialized and have undefined values
- integral types
- scope
  - block = sequence of zero or more statements enclosed in curly braces
- top-level const
- type checking = the compiler checks that the way objects of a given type are used is consistent with the definition of that type
- type specifier = the name of a type
- preprocessor
- void* = pointer type that can point to any nonconst type. (Cannot be dereferenced)
- word = Large enough to hold an address E.g. 32 bit machine, 4byte word
- low-level const


Vocab ch03
- range for

- value initialization

- compiler extension
- container  = holds objects of a certain type
  - E.g. vector is a container type
- instantiation = compiler process
- direct initialization
- ptrdiff_t = machine dependent signed integral type defined in #include<cstddef>
              - large enough to hold the difference b/t 2 pointers to the largest possible array

- size_t = machine dependent unsigned integral type defined in #include<cstddef>
           - large enough to hold the size of the largest possible array

- off-the-end iterator

Vocab ch12 pg 491

- free store = heap

- heap = memory pool available for programmers to hold dynamically allocated objects

- new = allocates memory in the heap ('free store') 
         - E.g. new T allocates and constructs the object of type T
         - and return a pointer to that object
         - E.g. new [n] T allocates n objects of type T 
         - default allocation but you can provide optional initializers
 
- placement new = a different and improved new that takes additional args
                  e.g. new(nothrow)

- 'reference count' = Counter that tracks how many users share a common object.
                      Smart pointers use it to know when it's safe to delete memory
- smart pointer = Library type
                - acts like a pointer but can be checked to see if it's safe to use
                - deletes memory when appropriate
- unique_ptr = smart pointer
               - provides single ownership
               - an object is deleted when the unique_ptr to that object is destroyed 
               - unique_ptrs cannot be directly copied or assigned
- shared_ptr = smart pointer 
               - shared ownership of an object, 
               - an object is deleted when the last shared pointer is destroyed 
- weak_ptr = smart pointer that points to an object that a shared pointer manages.
             The sahred_ptr does not count weak_ptr's when decideding whether 
             or not to delete its object.

- allocator = class that allocates unconstructed memory
- dangling pointer = pointer that points to memory that had an object but no longer does.
                   - very hard to debug
- delete = frees memory allocated by new

- deleter = function passed to a smart pointer
            use in place of delete!
            to destroy the object to which the pointer is bound
- dynamically allocated = object allocated in the 'free store'
                          such objects exist until they are explicitly deleted or the program terminates
 
Ch 13 Vocab

- synthesized assignment constructor = moves the right hand operand to the left hand sid
                    It is like the copy-assignment or move-assignment operator
- synthesized copy/move constructor = generated by compiler when you don't define a constructor
- synthesized destructor = generated by compiler when you don't explicitly make a destructor. 
                           It has an empty body.


Ch 14 

- 'function object' = object of a class that defines an overloaded call operator.  Function objects can be used when functions are normally expected.

Ch 15

Dynamic binding = let's ignore type differences b/c at run time, you pick which 
                  version of a function to run based on an object's dynamic type.
                  It only applies to functions declared as 'virtual'
                  called through a reference or pointer


dynamic type = type of an object at run time

abstract base class = class that has pure virtual functions

pure virtual = classes with pure virtuals are abtract classes
               a pure virtual is delcared in the header using =0
               a pure virtual need not be (but may be) defined
               If a derived class does not define its own version of an inherited 
               pure virtual, then that class is said to be abstract as well

static type = a variable type that is defined or that an expression yields
              it is known at compile time

private inheritance = public + protected members of the base class are private members 
                      of the derived


refactoring = make related parts into a single abstraction
              typically classes are refactored to move data or 
              function members to the highest common point in the 
              hierarchy to avoid code duplication

abstract classes = 

OOO Object Oriented Programming Key ideas
1. data abstraction
2. inheritance
3. dynamic binding 

protected = a parent class wants to share its protected members with its children classes. But, it does not want outside access to those protected members.




  










                     


